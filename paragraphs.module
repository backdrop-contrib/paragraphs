<?php

define('PARAGRAPHS_DEFAULT_TITLE', 'Paragraph');
define('PARAGRAPHS_DEFAULT_TITLE_MULTIPLE', 'Paragraphs');
define('PARAGRAPHS_DEFAULT_EDIT_MODE', 'open');

/**
 * Loads a paragraphs item.
 *
 * @param $item_id
 *   The paragraphs item ID.
 * @param $reset
 *   Should we reset the entity cache?
 * @return ParagraphsItemEntity
 *   The paragraphs item entity or FALSE.
 */
function paragraphs_item_load($item_id, $reset = FALSE) {
  $result = paragraphs_item_load_multiple(array($item_id), array(), $reset);
  return $result ? reset($result) : FALSE;
}

/**
 * Loads a paragraphs revision.
 *
 * @param $revision_id
 *   The paragraphs revision ID.
 * @return ParagraphsItemEntity
 *   The paragraphs item entity or FALSE.
 */
function paragraphs_item_revision_load($revision_id) {
  return entity_revision_load('paragraphs_item', $revision_id);
}

/**
 * Loads paragraphs items.
 *
 * @param $ids
 *   An array of paragraphs item IDs or FALSE to load all.
 * @param $conditions
 *   Should we reset the entity cache?
 * @param $reset
 *   Should we reset the entity cache?
 * @return ParagraphsItemEntity[]
 *   An array of paragraphs item entities.
 */
function paragraphs_item_load_multiple($ids = array(), $conditions = array(), $reset = FALSE) {
  return entity_load('paragraphs_item', $ids, $conditions, $reset);
}

/**
 * Class for paragraphs_item entities.
 */
class ParagraphsItemEntity extends Entity {

  /**
   * paragraphs field info.
   *
   * @var array
   */
  protected $fieldInfo;

  /**
   * The host entity object.
   *
   * @var object
   */
  protected $hostEntity;

  /**
   * The host entity ID.
   *
   * @var integer
   */
  protected $hostEntityId;

  /**
   * The host entity revision ID if this is not the default revision.
   *
   * @var integer
   */
  protected $hostEntityRevisionId;

  /**
   * The host entity type.
   *
   * @var string
   */
  protected $hostEntityType;

  /**
   * The language under which the paragraphs item is stored.
   *
   * @var string
   */
  protected $langcode = LANGUAGE_NONE;

  /**
   * Entity ID.
   *
   * @var integer
   */
  public $item_id;

  /**
   * paragraphs revision ID.
   *
   * @var integer
   */
  public $revision_id;

  /**
   * The name of the field-collection field this item is associated with.
   *
   * @var string
   */
  public $field_name;

  /**
   * Whether this revision is the default revision.
   *
   * @var bool
   */
  public $default_revision = TRUE;

  /**
   * Whether the paragraphs item is archived, i.e. not in use.
   *
   * @see FieldCollectionItemEntity::isInUse()
   * @var bool
   */
  public $archived = FALSE;

  /**
   * Constructs the entity object.
   */
  public function __construct(array $values = array(), $entityType = NULL) {
    parent::__construct($values, 'paragraphs_item');
    if (isset($this->field_name)) {

      // Ok, we have the field name property, we can proceed and check the field's type
      $field_info = $this->fieldInfo();

      // We only allow paragraphs type field for this entity.
      if (!$field_info || $field_info['type'] != 'paragraphs') {
        throw new Exception("Invalid field name given: {$this->field_name} is not a paragraphs field.");
      }
    }
  }

  /**
   * Provides info about the field on the host entity, which embeds this
   * paragraphs item.
   */
  public function fieldInfo() {
    return field_info_field($this->field_name);
  }

  /**
   * Provides info of the field instance containing the reference to this
   * paragraphs item.
   */
  public function instanceInfo() {
    if ($this->fetchHostDetails()) {
      return field_info_instance($this->hostEntityType(), $this->field_name, $this->hostEntityBundle());
    }
  }

  /**
   * Returns the field instance label translated to interface language.
   */
  public function translatedInstanceLabel($langcode = NULL) {
    if ($info = $this->instanceInfo()) {
      if (module_exists('i18n_field')) {
        return i18n_string("field:{$this->field_name}:{$info['bundle']}:label", $info['label'], array('langcode' => $langcode));
      }
      return $info['label'];
    }
  }

  /**
   * Specifies the default label, which is picked up by label() by default.
   */
  public function defaultLabel() {
    if ($this->fetchHostDetails()) {

      // Don't show a label, our parent field already shows an label
      // If the user decides he wants to show one.
      return '';
    }

    // Should only happen when there is something wrong
    return t('Unconnected paragraphs item');
  }

  /**
   * Returns the path used to view the entity.
   */
  public function path() {
    return;
  }

  /**
   * Returns the URI as returned by entity_uri().
   */
  public function defaultUri() {
    return array(
      'path' => $this->path(),
    );
  }

  /**
   * Sets the host entity. Only possible during creation of a item.
   *
   * @param $entity_type
   *   The entity type of the host.
   * @param $entity
   *   The host entity.
   * @param $langcode
   *   (optional) The field language code we should use for host entity.
   * @param $create_link
   *   (optional) Whether a field-item linking the host entity to the field
   *   collection item should be created.
   * @throws Exception
   *   When you try to set the host when the item has already been created.
   */
  public function setHostEntity($entity_type, $entity, $langcode = LANGUAGE_NONE, $create_link = TRUE) {
    if (!empty($this->is_new)) {
      $this->hostEntityType = $entity_type;
      $this->hostEntity = $entity;
      $this->langcode = $langcode;

      list($this->hostEntityId, $this->hostEntityRevisionId) = entity_extract_ids($this->hostEntityType, $this->hostEntity);
      // If the host entity is not saved yet, set the id to FALSE. So
      // fetchHostDetails() does not try to load the host entity details.
      if (!isset($this->hostEntityId)) {
        $this->hostEntityId = FALSE;
      }
      // We are create a new paragraphs for a non-default entity, thus
      // set archived to TRUE.
      if (!entity_revision_is_default($entity_type, $entity)) {
        $this->hostEntityId = FALSE;
        $this->archived = TRUE;
      }
      if ($create_link) {
        $entity->{$this->field_name}[$this->langcode][] = array('entity' => $this);
      }
    }
    else {
      throw new Exception('The host entity may be set only during creation of a paragraphs item.');
    }
  }

  public function forceHostEntity($entity) {
    $this->hostEntity = $entity;
  }

  /**
   * Returns the host entity, which embeds this paragraph item.
   */
  public function hostEntity() {
    if ($this->fetchHostDetails()) {
      if (!isset($this->hostEntity) && $this->isInUse()) {
        $this->hostEntity = entity_load_single($this->hostEntityType, $this->hostEntityId);
      }
      elseif (!isset($this->hostEntity) && $this->hostEntityRevisionId) {
        $this->hostEntity = entity_revision_load($this->hostEntityType, $this->hostEntityRevisionId);
      }
      return $this->hostEntity;
    }
  }

  /**
   * Returns the entity type of the host entity, which embeds this
   * paragraph item.
   */
  public function hostEntityType() {
    if ($this->fetchHostDetails()) {
      return $this->hostEntityType;
    }
  }

  /**
   * Returns the id of the host entity, which embeds this paragraph item.
   */
  public function hostEntityId() {
    if ($this->fetchHostDetails()) {
      if (!$this->hostEntityId && $this->hostEntityRevisionId) {
        $this->hostEntityId = entity_id($this->hostEntityType, $this->hostEntity());
      }
      return $this->hostEntityId;
    }
  }

  /**
   * Returns the bundle of the host entity, which embeds this paragraphs
   * item.
   */
  public function hostEntityBundle() {
    if ($entity = $this->hostEntity()) {
      list($id, $rev_id, $bundle) = entity_extract_ids($this->hostEntityType, $entity);
      return $bundle;
    }
  }

  protected function fetchHostDetails() {
    if (!isset($this->hostEntityId)) {
      if ($this->item_id) {
        // For saved paragraphs, query the field data to determine the
        // right host entity.
        $query = new EntityFieldQuery();
        $query->fieldCondition($this->fieldInfo(), 'revision_id', $this->revision_id);
        if (!$this->isInUse()) {
          $query->age(FIELD_LOAD_REVISION);
        }
        $result = $query->execute();
        list($this->hostEntityType, $data) = each($result);

        if ($this->isInUse()) {
          $this->hostEntityId = $data ? key($data) : FALSE;
          $this->hostEntityRevisionId = FALSE;
        }
        // If we are querying for revisions, we get the revision ID.
        else {
          $this->hostEntityId = FALSE;
          $this->hostEntityRevisionId = $data ? key($data) : FALSE;
        }
      }
      else {
        // No host entity available yet.
        $this->hostEntityId = FALSE;
      }
    }
    return !empty($this->hostEntityId) || !empty($this->hostEntity) || !empty($this->hostEntityRevisionId);
  }

  /**
   * Determines the $delta of the reference pointing to this paragraph
   * item.
   */
  public function delta() {
    if (($entity = $this->hostEntity()) && isset($entity->{$this->field_name})) {
      foreach ($entity->{$this->field_name} as $langcode => &$data) {
        foreach ($data as $delta => $item) {
          if (isset($item['value']) && $item['value'] == $this->item_id) {
            $this->langcode = $langcode;
            return $delta;
          }
          elseif (isset($item['entity']) && $item['entity'] === $this) {
            $this->langcode = $langcode;
            return $delta;
          }
        }
      }
    }
  }

  /**
   * Determines the language code under which the item is stored.
   */
  public function langcode() {
    if ($this->delta() != NULL) {
      return $this->langcode;
    }
  }

  /**
   * Determines whether this paragraphs item revision is in use.
   *
   * paragraphs items may be contained in from non-default host entity
   * revisions. If the paragraphs item does not appear in the default
   * host entity revision, the item is actually not used by default and so
   * marked as 'archived'.
   * If the paragraphs item appears in the default revision of the host
   * entity, the default revision of the paragraphs item is in use there
   * and the collection is not marked as archived.
   */
  public function isInUse() {
    return $this->default_revision && !$this->archived;
  }

  /**
   * Save the paragraphs item.
   *
   * By default, always save the host entity, so modules are able to react
   * upon changes to the content of the host and any 'last updated' dates of
   * entities get updated.
   *
   * For creating an item a host entity has to be specified via setHostEntity()
   * before this function is invoked. For the link between the entities to be
   * fully established, the host entity object has to be updated to include a
   * reference on this paragraphs item during saving. So do not skip
   * saving the host for creating items.
   *
   * @param $skip_host_save
   *   (internal) If TRUE is passed, the host entity is not saved automatically
   *   and therefore no link is created between the host and the item or
   *   revision updates might be skipped. Use with care.
   */
  public function save($skip_host_save = FALSE) {
    // Make sure we have a host entity during creation.
    if (!empty($this->is_new) && !(isset($this->hostEntityId) || isset($this->hostEntity) || isset($this->hostEntityRevisionId))) {
      throw new Exception("Unable to create a paragraphs item without a given host entity.");
    }

    // Only save directly if we are told to skip saving the host entity. Else,
    // we always save via the host as saving the host might trigger saving
    // paragraphs items anyway (e.g. if a new revision is created).
    if ($skip_host_save) {
      return entity_get_controller($this->entityType)->save($this);
    }
    else {
      $host_entity = $this->hostEntity();
      if (!$host_entity) {
        throw new Exception("Unable to save a paragraph without a valid reference to a host entity.");
      }
      // If this is creating a new revision, also do so for the host entity.
      if (!empty($this->revision) || !empty($this->is_new_revision)) {
        $host_entity->revision = TRUE;
        if (!empty($this->default_revision)) {
          entity_revision_set_default($this->hostEntityType, $host_entity);
        }
      }
      // Set the host entity reference, so the item will be saved with the host.
      // @see paragraphs_field_presave()
      $delta = $this->delta();
      if (isset($delta)) {
        $host_entity->{$this->field_name}[$this->langcode][$delta] = array('entity' => $this);
      }
      else {
        $host_entity->{$this->field_name}[$this->langcode][] =  array('entity' => $this);
      }
      return entity_save($this->hostEntityType, $host_entity);
    }
  }

  /**
   * Deletes the paragraphs item and the reference in the host entity.
   */
  public function delete() {
    parent::delete();
    $this->deleteHostEntityReference();
  }

  /**
   * Deletes the host entity's reference of the paragraphs item.
   */
  protected function deleteHostEntityReference() {
    $delta = $this->delta();
    if ($this->item_id && isset($delta)) {
      unset($this->hostEntity->{$this->field_name}[$this->langcode][$delta]);
      entity_save($this->hostEntityType, $this->hostEntity);
    }
  }

  /**
   * Intelligently delete a paragraphs item revision.
   *
   * If a host entity is revisioned with its paragraphs items, deleting
   * a paragraphs item on the default revision of the host should not
   * delete the collection item from archived revisions too. Instead, we delete
   * the current default revision and archive the paragraph.
   *
   * If no revisions are left or the host is not revisionable, the whole item
   * is deleted.
   */
  public function deleteRevision($skip_host_update = FALSE) {
    if (!$this->revision_id) {
      return;
    }
    $info = entity_get_info($this->hostEntityType());
    if (empty($info['entity keys']['revision']) || !$this->hostEntity()) {
      return $this->delete();
    }
    if (!$skip_host_update) {
      // Just remove the item from the host, which cares about deleting the
      // item (depending on whether the update creates a new revision).
      $this->deleteHostEntityReference();
    }
    elseif (!$this->isDefaultRevision()) {
      entity_revision_delete('paragraphs_item', $this->revision_id);
    }
    // If deleting the default revision, take care!
    else {
      $row = db_select('paragraphs_item_revision', 'r')
        ->fields('r')
        ->condition('item_id', $this->item_id)
        ->condition('revision_id', $this->revision_id, '<>')
        ->execute()
        ->fetchAssoc();
      // If no other revision is left, delete. Else archive the item.
      if (!$row) {
        $this->delete();
      }
      else {
        // Make the other revision the default revision and archive the item.
        db_update('paragraphs_item')
          ->fields(array('archived' => 1, 'revision_id' => $row['revision_id']))
          ->condition('item_id', $this->item_id)
          ->execute();
        entity_get_controller('paragraphs_item')->resetCache(array($this->item_id));
        entity_revision_delete('paragraphs_item', $this->revision_id);
      }
    }
  }

  /**
   * Export the paragraphs item.
   *
   * Since paragraphs entities are not directly exportable (i.e., do not
   * have 'exportable' set to TRUE in hook_entity_info()) and since Features
   * calls this method when exporting the paragraphs as a field attached
   * to another entity, we return the export in the format expected by
   * Features, rather than in the normal Entity::export() format.
   */
  public function export($prefix = '') {
    // Based on code in EntityDefaultFeaturesController::export_render().
    $export = "entity_import('" . $this->entityType() . "', '";
    $export .= addcslashes(parent::export(), '\\\'');
    $export .= "')";
    return $export;
  }

  /**
   * Magic method to only serialize what's necessary.
   */
  public function __sleep() {
    $vars = get_object_vars($this);
    unset($vars['entityInfo'], $vars['idKey'], $vars['nameKey'], $vars['statusKey']);
    unset($vars['fieldInfo']);
    // Also do not serialize the host entity, but only if it has already an id.
    if ($this->hostEntity && ($this->hostEntityId || $this->hostEntityRevisionId)) {
      unset($vars['hostEntity']);
    }

    // Also key the returned array with the variable names so the method may
    // be easily overridden and customized.
    return drupal_map_assoc(array_keys($vars));
  }

  /**
   * Magic method to invoke setUp() on unserialization.
   *
   * @todo: Remove this once it appears in a released entity API module version.
   */
  public function __wakeup() {
    $this->setUp();
  }
}

class ParagraphsItemMetadataController extends EntityDefaultMetadataController {

  public function entityPropertyInfo() {
    $info = parent::entityPropertyInfo();
    $properties = &$info['paragraphs']['properties'];


    $properties['field_name']['label'] = t('Field name');
    $properties['field_name']['description'] = t('The machine-readable name of the paragraphs field containing this item.');
    $properties['field_name']['required'] = TRUE;

    $properties['host_entity'] = array(
      'label' => t('Host entity'),
      'type' => 'entity',
      'description' => t('The entity containing the paragraphs field.'),
      'getter callback' => 'paragraphs_item_get_host_entity',
      'setter callback' => 'paragraphs_item_set_host_entity',
      'required' => TRUE,
    );

    return $info;
  }

}

/**
 * Implements hook_entity_info().
 */
function paragraphs_entity_info() {
  $return['paragraphs_item'] = array(
    'label' => t('Paragraphs item'),
    'label callback' => 'entity_class_label',
    'uri callback' => 'entity_class_uri',
    'entity class' => 'ParagraphsItemEntity',
    'controller class' => 'EntityAPIController',
    'base table' => 'paragraphs_item',
    'revision table' => 'paragraphs_item_revision',
    'fieldable' => TRUE,
    // For integration with Redirect module.
    // @see http://drupal.org/node/1263884
    'redirect' => FALSE,
    'entity keys' => array(
      'id' => 'item_id',
      'revision' => 'revision_id',
      'bundle' => 'bundle',
    ),
    'module' => 'paragraphs',
    'view modes' => array(
      'full' => array(
        'label' => t('Full content'),
        'custom settings' => FALSE,
      ),
    ),
    'bundle keys' => array(
      'bundle' => 'bundle',
    ),
    'access callback' => 'paragraphs_item_access',
    'metadata controller class' => 'ParagraphsItemMetadataController'
  );

  $bundles = paragraphs_bundle_load();

  // Add info about the bundles. We do not use field_info_fields() but directly
  // use field_read_fields() as field_info_fields() requires built entity info
  // to work.
  foreach ($bundles as $machine_name => $bundle) {
    $return['paragraphs_item']['bundles'][$bundle->bundle] = array(
      'label' => t('Paragraphs bundle @bundle', array('@bundle' => $bundle->bundle)),
      'admin' => array(
        'path' => 'admin/structure/paragraphs/%paragraphs_bundle',
        'real path' => 'admin/structure/paragraphs/' . strtr($machine_name, array('_' => '-')),
        'bundle argument' => 3,
        'access arguments' => array('administer paragraphs bundles'),
      ),
    );
  }

  return $return;
}

function paragraphs_item_access() {
  // TODO: might want to do some checking here? Might not be needed as the host should do this.
  return TRUE;
}

/**
 * Implements hook_permission
 */
function paragraphs_permission() {
  $perms = array(
    'administer paragraphs bundles' => array(
      'title' => t('Administer paragraphs bundles'),
      'description' => t('Is able to administer paragraph bundles for the Paragraphs module'),
    ),
  );
  return $perms;
}


/**
 * Implements hook_menu
 */
function paragraphs_menu() {
  $items = array();
  $items['admin/structure/paragraphs'] = array(
    'title' => 'Paragraph Bundles',
    'description' => 'Manage Paragraph bundles',
    'page callback' => 'paragraphs_admin_bundle_overview',
    'access arguments' => array('administer paragraphs bundles'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'paragraphs.admin.inc',
  );
  $items['admin/structure/paragraphs/add'] = array(
    'title' => 'Add Paragraph Bundle',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('paragraphs_admin_bundle_form'),
    'access arguments' => array('administer paragraphs bundles'),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'paragraphs.admin.inc',
  );
  $items['admin/structure/paragraphs/%paragraphs_bundle'] = array(
    'title' => 'Edit Paragraph Bundle',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('paragraphs_admin_bundle_form', 3),
    'access arguments' => array('administer paragraphs bundles'),
    'file' => 'paragraphs.admin.inc',
  );
  $items['admin/structure/paragraphs/%paragraphs_bundle/delete'] = array(
    'title' => 'Delete Paragraph Bundle',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('paragraphs_admin_bundle_delete_form', 3),
    'access arguments' => array('administer paragraphs bundles'),
    'file' => 'paragraphs.admin.inc',
  );

  $items['paragraphs/edit/ajax'] = array(
    'title' => 'Edit item callback',
    'page callback' => 'paragraphs_edit_js',
    'delivery callback' => 'ajax_deliver',
    'access callback' => TRUE,
    'theme callback' => 'ajax_base_page_theme',
    'type' => MENU_CALLBACK,
    'file path' => 'includes',
    'file' => 'form.inc',
  );

  $items['paragraphs/remove/ajax'] = array(
    'title' => 'Remove item callback',
    'page callback' => 'paragraphs_remove_js',
    'delivery callback' => 'ajax_deliver',
    'access callback' => TRUE,
    'theme callback' => 'ajax_base_page_theme',
    'type' => MENU_CALLBACK,
    'file path' => 'includes',
    'file' => 'form.inc',
  );

  $items['paragraphs/deleteconfirm/ajax'] = array(
    'title' => 'Remove item callback',
    'page callback' => 'paragraphs_deleteconfirm_js',
    'delivery callback' => 'ajax_deliver',
    'access callback' => TRUE,
    'theme callback' => 'ajax_base_page_theme',
    'type' => MENU_CALLBACK,
    'file path' => 'includes',
    'file' => 'form.inc',
  );


  $items['paragraphs/restore/ajax'] = array(
    'title' => 'Restore item callback',
    'page callback' => 'paragraphs_restore_js',
    'delivery callback' => 'ajax_deliver',
    'access callback' => TRUE,
    'theme callback' => 'ajax_base_page_theme',
    'type' => MENU_CALLBACK,
    'file path' => 'includes',
    'file' => 'form.inc',
  );

  return $items;
}


/**
 * Implements hook_field_info().
 */
function paragraphs_field_info() {
  $info = array();
  $info['paragraphs'] = array(
    'label' => t('Paragraphs'),
    'description' => t('Paragraphs field using the paragraph bundles.'),
    'instance_settings' => array(
      'title' => PARAGRAPHS_DEFAULT_TITLE,
      'title_multiple' => PARAGRAPHS_DEFAULT_TITLE_MULTIPLE,
      'allowed_bundles' => array(),
    ),
    'default_widget' => 'paragraphs_hidden',
    'default_formatter' => 'paragraphs_view',
    'settings' => array(),
    'property_type' => 'paragraphs_item',
    'property_callbacks' => array('paragraphs_entity_metadata_property_callback'),
  );
  return $info;
}

/**
 * Implements hook_field_formatter_info().
 */
function paragraphs_field_formatter_info() {
  return array(
    'paragraphs_view' => array(
      'label' => t('Paragraphs items'),
      'field types' => array('paragraphs'),
      'settings' =>  array(
        'view_mode' => 'full',
      ),
    ),
  );
}

/**
 * Implements hook_field_formatter_settings_form().
 */
function paragraphs_field_formatter_settings_form($field, $instance, $view_mode, $form, &$form_state) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];
  $elements = array();

  if ($display['type'] == 'paragraphs_view') {

    $entity_type = entity_get_info('paragraphs_item');
    $options = array();
    foreach ($entity_type['view modes'] as $mode => $info) {
      $options[$mode] = $info['label'];
    }

    $elements['view_mode'] = array(
      '#type' => 'select',
      '#title' => t('View mode'),
      '#options' => $options,
      '#default_value' => $settings['view_mode'],
      '#description' => t('Select the view mode'),
    );
  }

  return $elements;
}

/**
 * Implements hook_field_formatter_settings_summary().
 */
function paragraphs_field_formatter_settings_summary($field, $instance, $view_mode) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];
  $output = array();


  if ($display['type'] == 'paragraphs_view') {
    $entity_type = entity_get_info('paragraphs_item');
    if (!empty($entity_type['view modes'][$settings['view_mode']]['label'])) {
      $output[] =  t('View mode: @mode', array('@mode' => $entity_type['view modes'][$settings['view_mode']]['label']));
    }
  }

  return implode('<br>', $output);
}

/**
 * Implements hook_field_formatter_view().
 */
function paragraphs_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $element = array();
  $settings = $display['settings'];

  switch ($display['type']) {
    case 'paragraphs_view':

      $view_mode = !empty($display['settings']['view_mode']) ? $display['settings']['view_mode'] : 'full';
      foreach ($items as $delta => $item) {
        if ($paragraph = paragraphs_field_get_entity($item)) {
          $element[$delta]['entity'] = $paragraph->view($view_mode);
          $element[$delta]['#theme_wrappers'] = array('paragraphs_view');
          $element[$delta]['#attributes']['class'][] = 'paragraphs-view';
          $element[$delta]['#attributes']['class'][] = 'clearfix';
          $element[$delta]['#attributes']['class'][] = drupal_clean_css_identifier('paragraphs-' . $paragraph->bundle);
          $element[$delta]['#attributes']['class'][] = drupal_clean_css_identifier('paragraphs-' . $paragraph->bundle . '-' . $view_mode);
        }
      }
      break;
  }

  return $element;
}

/**
 * Implements hook_field_widget_info().
 */
function paragraphs_field_widget_info() {
  return array(
    'paragraphs_hidden' => array(
      'label' => t('Hidden'),
      'field types' => array('paragraphs'),
      'behaviors' => array(
        'multiple values' => FIELD_BEHAVIOR_CUSTOM,
        'default value' => FIELD_BEHAVIOR_NONE,
      ),
    ),
    'paragraphs_embed' => array(
      'label' => t('Embedded'),
      'field types' => array('paragraphs'),
      'behaviors' => array(
        'multiple values' => FIELD_BEHAVIOR_CUSTOM,
        'default value' => FIELD_BEHAVIOR_NONE,
      ),
    ),
  );
}

/**
 * Implements hook_field_instance_settings_form().
 */
function paragraphs_field_instance_settings_form($field, $instance) {

  $settings = $instance['settings'];

  $bundles = array();
  $_bundles = paragraphs_bundle_load();
  foreach($_bundles as $machine_name => $bundle) {
    $bundles[$machine_name] = $bundle->name;
  }

  $element['allowed_bundles'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Allowed Paragraph bundles'),
    '#options' => $bundles,
    '#default_value' => isset($settings['allowed_bundles']) ? $settings['allowed_bundles'] : array(),
    '#element_validate' => array('paragraphs_field_instance_settings_form_empty_bundle_check'),
  );

  $element['title'] = array(
    '#type' => 'textfield',
    '#title' => t('Item Title'),
    '#description' => t('Label to appear as title on the button as "Add new [title]", this label is translatable'),
    '#default_value' => isset($settings['title']) ? $settings['title'] : PARAGRAPHS_DEFAULT_TITLE,
    '#required' => TRUE,
  );

  $element['title_multiple'] = array(
    '#type' => 'textfield',
    '#title' => t('Item Title multiple'),
    '#description' => t('Title in its multiple form.'),
    '#default_value' => isset($settings['title_multiple']) ? $settings['title_multiple'] : PARAGRAPHS_DEFAULT_TITLE_MULTIPLE,
    '#required' => TRUE,
  );

  $element['default_edit_mode'] = array(
    '#type' => 'select',
    '#title' => t('Default edit mode'),
    '#description' => t('The default edit mode the paragraph item is in.'),
    '#options' => array(
      'open' => t('Open'),
      'closed' => t('Closed'),
    ),
    '#default_value' => isset($settings['default_edit_mode']) ? $settings['default_edit_mode'] : PARAGRAPHS_DEFAULT_EDIT_MODE,
    '#required' => TRUE,
  );


  if(!count($bundles)) {
    $element['allowed_bundles_explain'] = array(
      '#type' => 'markup',
      '#markup' => t('You did not add any paragraph bundles yet, click !here to add one.', array('!here' => l(t('here'), 'admin/structure/paragraphs/add', array('query' => drupal_get_destination()))))
    );
  }


  $element['fieldset'] = array(
    '#type' => 'fieldset',
    '#title' => t('Default value'),
    '#collapsible' => FALSE,
    // As field_ui_default_value_widget() does, we change the #parents so that
    // the value below is writing to $instance in the right location.
    '#parents' => array('instance'),
  );
  // Be sure to set the default value to NULL, e.g. to repair old fields
  // that still have one.
  $element['fieldset']['default_value'] = array(
    '#type' => 'value',
    '#value' => NULL,
  );
  $element['fieldset']['content'] = array(
    '#pre' => '<p>',
    '#markup' => t('To specify a default value, configure it via the regular default value setting of each field that is part of the paragraph bundle. To do so, go to the <a href="!url">Manage fields</a> screen of the paragraph bundle.', array('!url' => url('admin/structure/paragraph'))),
    '#suffix' => '</p>',
  );
  return $element;
}

function paragraphs_field_instance_settings_form_empty_bundle_check($element, &$form_state, $form) {
  if (!count($element['#value'])) {
    form_error($element, t('Select at least one bundle.'));
  }
}


/**
 * Implements hook_field_settings_form().
 */
function paragraphs_field_settings_form($field, $instance) {

  $form = array();
  return $form;
}


/**
 * Implements hook_field_presave().
 *
 * Support saving paragraph items in @code $item['entity'] @endcode. This
 * may be used to seamlessly create paragraph items during host-entity
 * creation or to save changes to the host entity and its collections at once.
 */
function paragraphs_field_presave($host_entity_type, $host_entity, $field, $instance, $langcode, &$items) {
  foreach ($items as $key => &$item) {
    // In case the entity has been changed / created, save it and set the id.
    // If the host entity creates a new revision, save new item-revisions as
    // well.
    if (isset($item['entity']) || !empty($host_entity->revision)) {

      if ($entity = paragraphs_field_get_entity($item)) {

        if (!empty($entity->is_new)) {
          $entity->setHostEntity($host_entity_type, $host_entity, $langcode, FALSE);
        }

        // If the host entity is saved as new revision, do the same for the item.
        if (!empty($host_entity->revision)) {
          $entity->revision = TRUE;
          $is_default = entity_revision_is_default($host_entity_type, $host_entity);
          // If an entity type does not support saving non-default entities,
          // assume it will be saved as default.
          if (!isset($is_default) || $is_default) {
            $entity->default_revision = TRUE;
            $entity->archived = FALSE;
          }
        }
        if(isset($entity->removed) && $entity->removed) {
          unset($items[$key]);
        } else {
          $entity->save(TRUE);

          $item = array(
            'value' => $entity->item_id,
            'revision_id' => $entity->revision_id,
          );
        }
      }
    }
  }
}


/**
 * Implements hook_field_update().
 *
 * Care about removed paragraph items.
 */
function paragraphs_field_update($entity_type, $entity, $field, $instance, $langcode, &$items) {
  // Prevent workbench moderation from deleting paragraphs on node_save() during
  // workbench_moderation_store(), when $host_entity->revision == 0.
  if (!empty($entity->workbench_moderation['updating_live_revision'])) {
    return;
  }

  $items_original = !empty($entity->original->{$field['field_name']}[$langcode]) ? $entity->original->{$field['field_name']}[$langcode] : array();
  $original_by_id = array_flip(paragraphs_field_item_to_ids($items_original));

  foreach ($items as $item) {
    unset($original_by_id[$item['value']]);
  }

  // If there are removed items, care about deleting the item entities.
  if ($original_by_id) {
    $ids = array_flip($original_by_id);

    // If we are creating a new revision, the old-items should be kept but get
    // marked as archived now.
    if (!empty($entity->revision)) {
      db_update('paragraphs_item')
        ->fields(array('archived' => 1))
        ->condition('item_id', $ids, 'IN')
        ->execute();
    }
    else {
      // Delete unused paragraph items now.
      foreach (paragraphs_item_load_multiple($ids) as $item) {
        $item->forceHostEntity($entity);
        $item->deleteRevision(TRUE);
      }
    }
  }
}

/**
 * Implements hook_field_delete().
 */
function paragraphs_field_delete($entity_type, $entity, $field, $instance, $langcode, &$items) {
  if ($field['type'] == 'paragraphs') {
    // Also delete all embedded entities.
    if ($ids = paragraphs_field_item_to_ids($items)) {
      // We filter out entities that are still being referenced by other
      // host-entities. This should never be the case, but it might happened e.g.
      // when modules cloned a node without knowing about field-collection.
      $entity_info = entity_get_info($entity_type);
      $entity_id_name = $entity_info['entity keys']['id'];
      $field_column = key($field['columns']);

      foreach ($ids as $id_key => $id) {
        $query = new EntityFieldQuery();
        $entities = $query
          ->fieldCondition($field['field_name'], $field_column, $id)
          ->execute();
        unset($entities[$entity_type][$entity->$entity_id_name]);

        if (!empty($entities[$entity_type])) {
          // Filter this $id out.
          unset($ids[$id_key]);
        }
      }

      entity_delete_multiple('paragraphs_items', $ids);
    }
  }
}

/**
 * Implements hook_field_delete_revision().
 */
function paragraphs_field_delete_revision($entity_type, $entity, $field, $instance, $langcode, &$items) {
  if ($field['type'] == 'paragraphs') {
    foreach ($items as $item) {
      if (!empty($item['revision_id'])) {
        if ($entity = paragraphs_item_revision_load($item['revision_id'])) {
          $entity->deleteRevision(TRUE);
        }
      }
    }
  }
}

/**
 * Get an array of paragraph item IDs stored in the given field items.
 */
function paragraphs_field_item_to_ids($items) {
  $ids = array();
  foreach ($items as $item) {
    if (!empty($item['value'])) {
      $ids[] = $item['value'];
    }
  }
  return $ids;
}

/**
 * Implements hook_field_is_empty().
 */
function paragraphs_field_is_empty($item, $field) {
  if (!empty($item['value'])) {
    return FALSE;
  }
  elseif (isset($item['entity'])) {
    return FALSE;
  }
  return TRUE;
}

/**
 * Determines whether a field paragraphs item entity is empty based on the paragraphs-field.
 */
function paragraphs_item_is_empty(ParagraphsItemEntity $item) {
  $instances = field_info_instances('paragraphs_item', $item->bundle);
  $is_empty = TRUE;

  foreach ($instances as $instance) {
    $field_name = $instance['field_name'];
    $field = field_info_field($field_name);

    // Determine the list of languages to iterate on.
    $languages = field_available_languages('paragraphs_item', $field);

    foreach ($languages as $langcode) {
      if (!empty($item->{$field_name}[$langcode])) {
        // If at least one collection-field is not empty; the
        // paragraph item is not empty.
        foreach ($item->{$field_name}[$langcode] as $field_item) {
          if (!module_invoke($field['module'], 'field_is_empty', $field_item, $field)) {
            $is_empty = FALSE;
          }
        }
      }
    }
  }

  // Allow other modules a chance to alter the value before returning.
  drupal_alter('paragraphs_is_empty', $is_empty, $item);
  return $is_empty;
}

/*
 * Load a specific bundle or a list of bundles
 */
function paragraphs_bundle_load($name = NULL, $rebuild = FALSE) {
  $cid = 'paragraphs_bundles';
  $bundles = array();

  // Load bundles from static or from Drupal cache
  $_bundles = &drupal_static($cid);
  if (isset($_bundles) && !$rebuild) {
    $bundles = $_bundles;
  } else {
    $_bundles = cache_get($cid);
    if ($_bundles && !$rebuild) {
      $bundles = $_bundles->data;
    } else {
      $query = db_select('paragraphs_bundle', 'pb')
        ->fields('pb')
        ->orderBy('pb.bundle', 'ASC');
      foreach ($query->execute() as $bundle_object) {
        $bundles[$bundle_object->bundle] = $bundle_object;
      }
      cache_set($cid, $bundles);
    }
    $_bundles = $bundles;
  }

  if($name) {
    $name = strtr($name, array('-' => '_'));
    if(isset($bundles[$name])) {
      return $bundles[$name];
    }
    return FALSE;
  } else {
    return $bundles;
  }
}

function paragraphs_bundle_save($bundle) {
  $is_existing = (bool) db_query_range('SELECT 1 FROM {paragraphs_bundle} WHERE bundle = :bundle', 0, 1, array(':bundle' => $bundle->bundle))->fetchField();

  $fields = array(
    'bundle' => (string) $bundle->bundle,
    'name' => (string) $bundle->name,
    'locked' => (int) $bundle->locked,
  );

  if ($is_existing) {
    db_update('paragraphs_bundle')
      ->fields($fields)
      ->condition('bundle', $bundle->bundle)
      ->execute();
    $status = SAVED_UPDATED;
  }
  else {
    db_insert('paragraphs_bundle')
      ->fields($fields)
      ->execute();

    $status = SAVED_NEW;
  }

  paragraphs_bundle_load(NULL, TRUE);
  entity_info_cache_clear();
  variable_set('menu_rebuild_needed', TRUE);
  return $status;
}

function paragraphs_bundle_delete($bundle_machine_name) {
  $bundle = paragraphs_bundle_load($bundle_machine_name);
  if($bundle) {
    db_delete('paragraphs_bundle')
      ->condition('bundle', $bundle->bundle)
      ->execute();
    field_attach_delete_bundle('paragraphs_item', $bundle->bundle);
    paragraphs_bundle_load(NULL, TRUE);
    entity_info_cache_clear();
    variable_set('menu_rebuild_needed', TRUE);
  }
}

function paragraphs_field_widget_form_build(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  static $recursion = 0;

  if(!isset($instance['settings']['title'])) {
    $instance['settings']['title'] = PARAGRAPHS_DEFAULT_TITLE;
  }
  if(!isset($instance['settings']['title_multiple'])) {
    $instance['settings']['title_multiple'] = PARAGRAPHS_DEFAULT_TITLE_MULTIPLE;
  }

  // If the paragraph item form contains another paragraph,
  // we might ran into a recursive loop. Prevent that.
  if ($recursion++ > 3) {
    drupal_set_message(t('The paragraphs item form has not been embedded to avoid recursive loops.'), 'error');
    return $element;
  }
  $field_parents = $element['#field_parents'];
  $field_name = $element['#field_name'];
  $language = $element['#language'];

  $bundle = FALSE;
  $id_prefix = implode('-', array_merge($field_parents, array($field_name)));
  if(isset($form_state['input'][strtr($id_prefix, '-', '_') . '_add_more_type'])) {
    $bundle = $form_state['input'][strtr($id_prefix, '-', '_') . '_add_more_type'];
  }

  // Nest the paragraphs item entity form in a dedicated parent space,
  // by appending [field_name, langcode, delta] to the current parent space.
  // That way the form values of the paragraphs item are separated.
  $parents = array_merge($field_parents, array($field_name, $language, $delta));

  $element += array(
    '#element_validate' => array('paragraphs_field_widget_embed_validate'),
    '#parents' => $parents,
  );

  $field_state = field_form_get_state($field_parents, $field_name, $language, $form_state);

  $deleted_paragraph = FALSE;

  $default_edit_mode = isset($instance['settings']['default_edit_mode']) ? $instance['settings']['default_edit_mode'] : PARAGRAPHS_DEFAULT_EDIT_MODE;

  $being_edited_paragraph = TRUE;
  if($default_edit_mode === 'closed') {
    $being_edited_paragraph = FALSE;
  }

  if (isset($field_state['entity'][$delta])) {
    if(isset($field_state['entity'][$delta]->removed) && $field_state['entity'][$delta]->removed) {
      $deleted_paragraph = TRUE;
    }
    if($being_edited_paragraph || (isset($field_state['entity'][$delta]->being_edited) && $field_state['entity'][$delta]->being_edited)) {
      $being_edited_paragraph = TRUE;
    } else {
      $being_edited_paragraph = FALSE;
    }
    $paragraph_item = $field_state['entity'][$delta];
  }
  else {
    if (isset($items[$delta])) {
      $paragraph_item = paragraphs_field_get_entity($items[$delta]);
    }

    // Show an empty collection if we have no existing one or it does not
    // load.
    if (empty($paragraph_item) && $bundle) {
      $paragraph_item = entity_create('paragraphs_item', array('bundle' => $bundle, 'field_name' => $field_name));
      $paragraph_item->being_edited = TRUE;
      $being_edited_paragraph = TRUE;
    }

    if (!empty($paragraph_item)) {
      // Put our entity in the form state, so FAPI callbacks can access it.
      $field_state['entity'][$delta] = $paragraph_item;
    }
  }
  field_form_set_state($field_parents, $field_name, $language, $form_state, $field_state);
  if (!empty($paragraph_item)) {
    $bundle_info = paragraphs_bundle_load($paragraph_item->bundle);

    if($bundle_info) {

      $element['title'] = array(
        '#markup' => t('!title type: %bundle', array('!title' => t($instance['settings']['title']), '%bundle' => $bundle_info->name)),
        '#weight' => -100,
      );
    }

    if(!$deleted_paragraph) {
      $element['actions'] = array(
        '#type' => 'actions',
        '#weight' => 9999,
      );
      if($being_edited_paragraph) {
        field_attach_form('paragraphs_item', $paragraph_item, $element, $form_state, $language);
        if (empty($element['#required'])) {
          $element['#after_build'][] = 'paragraphs_field_widget_embed_delay_required_validation';
        }
      } else {
        $element['actions'] = array(
          '#type' => 'actions',
          '#weight' => 9999,
        );
        $element['actions']['edit_button'] = array(
          '#delta' => $delta,
          '#name' => implode('_', $parents) . '_edit_button',
          '#type' => 'submit',
          '#value' => t('Edit'),
          '#validate' => array(),
          '#submit' => array('paragraphs_edit_submit'),
          '#limit_validation_errors' => array(),
          '#ajax' => array(
            'path' => 'paragraphs/edit/ajax',
            'effect' => 'fade',
          ),
          '#weight' => 999,
        );
      }


      if (isset($paragraph_item)) {
        $element['actions']['remove_button'] = array(
          '#delta' => $delta,
          '#name' => implode('_', $parents) . '_remove_button',
          '#type' => 'submit',
          '#value' => t('Remove'),
          '#validate' => array(),
          '#submit' => array('paragraphs_remove_submit'),
          '#limit_validation_errors' => array(),
          '#ajax' => array(
            'path' => 'paragraphs/remove/ajax',
            'effect' => 'fade',
          ),
          '#weight' => 1000,
        );
      }
    } else {
      $element['actions'] = array(
        '#type' => 'actions',
        '#weight' => 9999,
      );
      $element['actions']['remove_button'] = array(
        '#markup' => '<p>' . t('This !title has been removed, press the button below to restore.', array('!title' => t($instance['settings']['title']))) . ' </p><p><em>' . t('Warning: this !title will actually be deleted when you press "!confirm" or "!save"!', array('!title' => $instance['settings']['title'], '!confirm' => t('Confirm Deletion'), '!save' => t('Save'))) . '</em></p>',
      );
      $element['actions']['restore_button'] = array(
        '#delta' => $delta,
        '#name' => implode('_', $parents) . '_restore_button',
        '#type' => 'submit',
        '#value' => t('Restore'),
        '#validate' => array(),
        '#submit' => array('paragraphs_restore_submit'),
        '#limit_validation_errors' => array(),
        '#ajax' => array(
          'path' => 'paragraphs/restore/ajax',
          'effect' => 'fade',
        ),
        '#weight' => 1000,
      );
      $element['actions']['confirm_delete_button'] = array(
        '#delta' => $delta,
        '#name' => implode('_', $parents) . '_deleteconfirm_button',
        '#type' => 'submit',
        '#value' => t('Confirm Deletion'),
        '#validate' => array(),
        '#submit' => array('paragraphs_deleteconfirm_submit'),
        '#limit_validation_errors' => array(),
        '#ajax' => array(
          'path' => 'paragraphs/deleteconfirm/ajax',
          'effect' => 'fade',
        ),
        '#weight' => 1001,
      );
    }
  }

  $recursion--;
  return $element;
}

/**
 * Implements hook_field_widget_form().
 */
function paragraphs_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  switch ($instance['widget']['type']) {
    case 'paragraphs_hidden':
      return $element;

      break;
    case 'paragraphs_embed':
      $form['#entity'] = $element['#entity'];
      return paragraphs_field_multiple_value_form($field, $instance, $langcode, $items, $form, $form_state);
      break;
  }
}

/**
 * FAPI #after_build of an individual paragraph element to delay the validation of #required.
 */
function paragraphs_field_widget_embed_delay_required_validation(&$element, &$form_state) {
  // If the process_input flag is set, the form and its input is going to be
  // validated. Prevent #required (sub)fields from throwing errors while
  // their non-#required paragraph item is empty.
  if ($form_state['process_input']) {
    _paragraphs_collect_required_elements($element, $element['#paragraphs_required_elements']);
  }
  return $element;
}

function _paragraphs_collect_required_elements(&$element, &$required_elements) {
  // Recurse through all children.
  foreach (element_children($element) as $key) {
    if (isset($element[$key]) && $element[$key]) {
      _paragraphs_collect_required_elements($element[$key], $required_elements);
    }
  }
  if (!empty($element['#required'])) {
    $required_elements[] = &$element;
    $element += array('#pre_render' => array());
    array_unshift($element['#pre_render'], 'paragraphs_field_widget_render_required');
  }
}

/**
 * #pre_render callback that ensures the element is rendered as being required.
 */
function paragraphs_field_widget_render_required($element) {
  $element['#required'] = TRUE;
  return $element;
}

/**
 * FAPI validation of an individual paragraph element.
 */
function paragraphs_field_widget_embed_validate($element, &$form_state, $complete_form) {
  $instance = field_widget_instance($element, $form_state);
  $field = field_widget_field($element, $form_state);
  $field_parents = $element['#field_parents'];
  $field_name = $element['#field_name'];
  $language = $element['#language'];

  $field_state = field_form_get_state($field_parents, $field_name, $language, $form_state);
  if(isset($field_state['entity'][$element['#delta']])) {
    $paragraph_item = $field_state['entity'][$element['#delta']];

    // Attach field API validation of the embedded form.
    field_attach_form_validate('paragraphs_item', $paragraph_item, $element, $form_state);

    // Now validate required elements if the entity is not empty.
    if ((!isset($paragraph_item->removed) || !$paragraph_item->removed) && !empty($element['#paragraphs_required_elements'])) {
      foreach ($element['#paragraphs_required_elements'] as &$elements) {

        // Copied from _form_validate().
        if (isset($elements['#needs_validation'])) {
          $is_empty_multiple = (!count($elements['#value']));
          $is_empty_string = (is_string($elements['#value']) && drupal_strlen(trim($elements['#value'])) == 0);
          $is_empty_value = ($elements['#value'] === 0);
          if ($is_empty_multiple || $is_empty_string || $is_empty_value) {
            if (isset($elements['#title'])) {
              form_error($elements, t('!name field is required.', array('!name' => $elements['#title'])));
            }
            else {
              form_error($elements);
            }
          }
        }
      }
    }

    // Only if the form is being submitted, finish the collection entity and
    // prepare it for saving.
    if ($form_state['submitted'] && !form_get_errors()) {

      field_attach_submit('paragraphs_item', $paragraph_item, $element, $form_state);

      // Load initial form values into $item, so any other form values below the
      // same parents are kept.
      $item = drupal_array_get_nested_value($form_state['values'], $element['#parents']);

      // Set the _weight if it is a multiple field.
      if (isset($element['_weight'])) {
        $item['_weight'] = $element['_weight']['#value'];
      }

      // Put the paragraph item in $item['entity'], so it is saved with
      // the host entity via hook_field_presave() / field API if it is not empty.
      // @see paragraph_field_presave()
      $item['entity'] = $paragraph_item;
      form_set_value($element, $item, $form_state);
    }
  }
}

/**
 * Entity property info setter callback for the host entity property.
 *
 * As the property is of type entity, the value will be passed as a wrapped
 * entity.
 */
function paragraphs_item_set_host_entity($item, $property_name, $wrapper) {
  if (empty($item->is_new)) {
    throw new EntityMetadataWrapperException('The host entity may be set only during creation of a paragraphs item.');
  }
  $item->setHostEntity($wrapper->type(), $wrapper->value());
}

/**
 * Entity property info getter callback for the host entity property.
 */
function paragraphs_item_get_host_entity($item) {
  // As the property is defined as 'entity', we have to return a wrapped entity.
  return entity_metadata_wrapper($item->hostEntityType(), $item->hostEntity());
}

/**
 * Callback for generating entity metadata property info for our field instances.
 *
 * @see paragraphs_field_info()
 */
function paragraphs_entity_metadata_property_callback(&$info, $entity_type, $field, $instance, $field_type) {
  $property = &$info[$entity_type]['bundles'][$instance['bundle']]['properties'][$field['field_name']];

  $property['field_name'] = $field['field_name'];
  $property['getter callback'] = 'paragraphs_field_property_get';
}

/**
 * Entity property info getter callback for the paragraph items.
 *
 * Like entity_metadata_field_property_get(), but additionally supports getting
 * not-yet saved collection items from @code $item['entity'] @endcode.
 */
function paragraphs_field_property_get($entity, array $options, $name, $entity_type, $info) {
  $field = field_info_field($name);
  $langcode = field_language($entity_type, $entity, $name, isset($options['language']) ? $options['language']->language : NULL);
  $values = array();
  if (isset($entity->{$name}[$langcode])) {
    foreach ($entity->{$name}[$langcode] as $delta => $data) {
      // Wrappers do not support multiple entity references being revisions or
      // not yet saved entities. In the case of a single reference we can return
      // the entity object though.
      if ($field['cardinality'] == 1) {
        $values[$delta] = paragraphs_field_get_entity($data);
      }
      elseif (isset($data['value'])) {
        $values[$delta] = $data['value'];
      }
    }
  }
  // For an empty single-valued field, we have to return NULL.
  return $field['cardinality'] == 1 ? ($values ? reset($values) : NULL) : $values;
}


/**
 * Submit callback to remove an item from the field UI multiple wrapper.
 *
 * When a remove button is submitted, we need to find the item that it
 * referenced and delete it. Since field UI has the deltas as a straight
 * unbroken array key, we have to renumber everything down. Since we do this
 * we *also* need to move all the deltas around in the $form_state['values']
 * and $form_state['input'] so that user changed values follow. This is a bit
 * of a complicated process.
 */
function paragraphs_remove_submit($form, &$form_state) {
  $button = $form_state['triggering_element'];
  $delta = $button['#delta'];

  // Where in the form we'll find the parent element.
  $address = array_slice($button['#array_parents'], 0, -3);

  // Go one level up in the form, to the widgets container.
  $parent_element = drupal_array_get_nested_value($form, $address);
  $field_name = $parent_element['#field_name'];
  $langcode = $parent_element['#language'];
  $parents = $parent_element['#field_parents'];

  $field_state = field_form_get_state($parents, $field_name, $langcode, $form_state);

  if(isset($field_state['entity'][$delta])) {
    $field_state['entity'][$delta]->removed = 1;
  }


  // Fix the weights. Field UI lets the weights be in a range of
  // (-1 * item_count) to (item_count). This means that when we remove one,
  // the range shrinks; weights outside of that range then get set to
  // the first item in the select by the browser, floating them to the top.
  // We use a brute force method because we lost weights on both ends
  // and if the user has moved things around, we have to cascade because
  // if I have items weight weights 3 and 4, and I change 4 to 3 but leave
  // the 3, the order of the two 3s now is undefined and may not match what
  // the user had selected.
  $input = drupal_array_get_nested_value($form_state['input'], $address);
  // Sort by weight,
  // but first remove garbage values to ensure proper '_weight' sorting
  unset($input['add_more']);
  uasort($input, '_field_sort_items_helper');

  // Reweight everything in the correct order.
  $weight = -1 * $field_state['items_count'] + 1;
  foreach ($input as $key => $item) {
    if ($item) {
      $input[$key]['_weight'] = $weight++;
    }
  }

  drupal_array_set_nested_value($form_state['input'], $address, $input);
  field_form_set_state($parents, $field_name, $langcode, $form_state, $field_state);

  $form_state['rebuild'] = TRUE;
}


/**
 * Submit callback to editing an item from the field UI multiple wrapper.
 *
 * When a edited button is submitted, we need to find the item that it
 * referenced and delete it. Since field UI has the deltas as a straight
 * unbroken array key, we have to renumber everything down. Since we do this
 * we *also* need to move all the deltas around in the $form_state['values']
 * and $form_state['input'] so that user changed values follow. This is a bit
 * of a complicated process.
 */
function paragraphs_edit_submit($form, &$form_state) {
  $button = $form_state['triggering_element'];
  $delta = $button['#delta'];

  // Where in the form we'll find the parent element.
  $address = array_slice($button['#array_parents'], 0, -3);

  // Go one level up in the form, to the widgets container.
  $parent_element = drupal_array_get_nested_value($form, $address);
  $field_name = $parent_element['#field_name'];
  $langcode = $parent_element['#language'];
  $parents = $parent_element['#field_parents'];

  $field_state = field_form_get_state($parents, $field_name, $langcode, $form_state);

  if(isset($field_state['entity'][$delta])) {
    $field_state['entity'][$delta]->being_edited = 1;
  }


  // Fix the weights. Field UI lets the weights be in a range of
  // (-1 * item_count) to (item_count). This means that when we remove one,
  // the range shrinks; weights outside of that range then get set to
  // the first item in the select by the browser, floating them to the top.
  // We use a brute force method because we lost weights on both ends
  // and if the user has moved things around, we have to cascade because
  // if I have items weight weights 3 and 4, and I change 4 to 3 but leave
  // the 3, the order of the two 3s now is undefined and may not match what
  // the user had selected.
  $input = drupal_array_get_nested_value($form_state['input'], $address);
  // Sort by weight,
  // but first remove garbage values to ensure proper '_weight' sorting
  unset($input['add_more']);
  uasort($input, '_field_sort_items_helper');

  // Reweight everything in the correct order.
  $weight = -1 * $field_state['items_count'] + 1;
  foreach ($input as $key => $item) {
    if ($item) {
      $input[$key]['_weight'] = $weight++;
    }
  }

  drupal_array_set_nested_value($form_state['input'], $address, $input);
  field_form_set_state($parents, $field_name, $langcode, $form_state, $field_state);

  $form_state['rebuild'] = TRUE;
}

/**
 * Submit callback to remove an item from the field UI multiple wrapper.
 *
 * When a remove button is submitted, we need to find the item that it
 * referenced and delete it. Since field UI has the deltas as a straight
 * unbroken array key, we have to renumber everything down. Since we do this
 * we *also* need to move all the deltas around in the $form_state['values']
 * and $form_state['input'] so that user changed values follow. This is a bit
 * of a complicated process.
 */
function paragraphs_deleteconfirm_submit($form, &$form_state) {
  $button = $form_state['triggering_element'];
  $delta = $button['#delta'];

  // Where in the form we'll find the parent element.
  $address = array_slice($button['#array_parents'], 0, -3);

  // Go one level up in the form, to the widgets container.
  $parent_element = drupal_array_get_nested_value($form, $address);
  $field_name = $parent_element['#field_name'];
  $langcode = $parent_element['#language'];
  $parents = $parent_element['#field_parents'];

  $field_state = field_form_get_state($parents, $field_name, $langcode, $form_state);

  // Go ahead and renumber everything from our delta to the last
  // item down one. This will overwrite the item being removed.
  for ($i = $delta; $i <= $field_state['items_count']; $i++) {
    $old_element_address = array_merge($address, array($i + 1));
    $new_element_address = array_merge($address, array($i));

    $moving_element = drupal_array_get_nested_value($form, $old_element_address);
    $moving_element_value = drupal_array_get_nested_value($form_state['values'], $old_element_address);
    $moving_element_input = drupal_array_get_nested_value($form_state['input'], $old_element_address);

    // Tell the element where it's being moved to.
    $moving_element['#parents'] = $new_element_address;

    // Move the element around.
    form_set_value($moving_element, $moving_element_value, $form_state);
    drupal_array_set_nested_value($form_state['input'], $moving_element['#parents'], $moving_element_input);

    // Move the entity in our saved state.
    if (isset($field_state['entity'][$i + 1])) {
      $field_state['entity'][$i] = $field_state['entity'][$i + 1];
    }
    else {
      unset($field_state['entity'][$i]);
    }
  }

  // Replace the deleted entity with an empty one. This helps to ensure that
  // trying to add a new entity won't ressurect a deleted entity from the
  // trash bin.
  $count = count($field_state['entity']);
  unset($field_state['entity'][$count]);

  // Then remove the last item. But we must not go negative.
  if ($field_state['items_count'] > 0) {
    $field_state['items_count']--;
  }

  // Fix the weights. Field UI lets the weights be in a range of
  // (-1 * item_count) to (item_count). This means that when we remove one,
  // the range shrinks; weights outside of that range then get set to
  // the first item in the select by the browser, floating them to the top.
  // We use a brute force method because we lost weights on both ends
  // and if the user has moved things around, we have to cascade because
  // if I have items weight weights 3 and 4, and I change 4 to 3 but leave
  // the 3, the order of the two 3s now is undefined and may not match what
  // the user had selected.
  $input = drupal_array_get_nested_value($form_state['input'], $address);
  // Sort by weight,
  // but first remove garbage values to ensure proper '_weight' sorting
  unset($input['add_more']);
  uasort($input, '_field_sort_items_helper');

  // Reweight everything in the correct order.
  $weight = -1 * $field_state['items_count'] + 1;
  foreach ($input as $key => $item) {
    if ($item) {
      $input[$key]['_weight'] = $weight++;
    }
  }

  drupal_array_set_nested_value($form_state['input'], $address, $input);
  field_form_set_state($parents, $field_name, $langcode, $form_state, $field_state);

  $form_state['rebuild'] = TRUE;
}


function paragraphs_restore_submit($form, &$form_state) {
  $button = $form_state['triggering_element'];
  $delta = $button['#delta'];

  // Where in the form we'll find the parent element.
  $address = array_slice($button['#array_parents'], 0, -3);

  // Go one level up in the form, to the widgets container.
  $parent_element = drupal_array_get_nested_value($form, $address);
  $field_name = $parent_element['#field_name'];
  $langcode = $parent_element['#language'];
  $parents = $parent_element['#field_parents'];

  $field_state = field_form_get_state($parents, $field_name, $langcode, $form_state);


  if(isset($field_state['entity'][$delta])) {
    $field_state['entity'][$delta]->removed = 0;
  }


  // Fix the weights. Field UI lets the weights be in a range of
  // (-1 * item_count) to (item_count). This means that when we remove one,
  // the range shrinks; weights outside of that range then get set to
  // the first item in the select by the browser, floating them to the top.
  // We use a brute force method because we lost weights on both ends
  // and if the user has moved things around, we have to cascade because
  // if I have items weight weights 3 and 4, and I change 4 to 3 but leave
  // the 3, the order of the two 3s now is undefined and may not match what
  // the user had selected.
  $input = drupal_array_get_nested_value($form_state['input'], $address);
  // Sort by weight,
  // but first remove garbage values to ensure proper '_weight' sorting
  unset($input['add_more']);
  uasort($input, '_field_sort_items_helper');

  // Reweight everything in the correct order.
  $weight = -1 * $field_state['items_count'] + 1;
  foreach ($input as $key => $item) {
    if ($item) {
      $input[$key]['_weight'] = $weight++;
    }
  }

  drupal_array_set_nested_value($form_state['input'], $address, $input);
  field_form_set_state($parents, $field_name, $langcode, $form_state, $field_state);

  $form_state['rebuild'] = TRUE;

}


/**
 * Page callback to handle AJAX for editing a paragraphs item.
 *
 * This is a direct page callback. The actual job of deleting the item is
 * done in the submit handler for the button, so all we really need to
 * do is process the form and then generate output. We generate this
 * output by doing a replace command on the id of the entire form element.
 */
function paragraphs_edit_js() {
  // drupal_html_id() very helpfully ensures that all html IDS are unique
  // on a page. Unfortunately what it doesn't realize is that the IDs
  // we are generating are going to replace IDs that already exist, so
  // this actually works against us.
  if (isset($_POST['ajax_html_ids'])) {
    unset($_POST['ajax_html_ids']);
  }

  list($form, $form_state) = ajax_get_form();
  drupal_process_form($form['#form_id'], $form, $form_state);

  // Get the information on what we're removing.
  $button = $form_state['triggering_element'];
  // Go two levels up in the form, to the whole widget.
  $element = drupal_array_get_nested_value($form, array_slice($button['#array_parents'], 0, -4));
  // Now send back the proper AJAX command to replace it.
  $return = array(
    '#type' => 'ajax',
    '#commands' => array(
      ajax_command_replace('#' . $element['#id'], drupal_render($element))
    ),
  );

  // Because we're doing this ourselves, messages aren't automatic. We have
  // to add them.
  $messages = theme('status_messages');
  if ($messages) {
    $return['#commands'][] = ajax_command_prepend('#' . $element['#id'], $messages);
  }

  return $return;
}

/**
 * Page callback to handle AJAX for removing a paragraphs item.
 *
 * This is a direct page callback. The actual job of deleting the item is
 * done in the submit handler for the button, so all we really need to
 * do is process the form and then generate output. We generate this
 * output by doing a replace command on the id of the entire form element.
 */
function paragraphs_remove_js() {
  // drupal_html_id() very helpfully ensures that all html IDS are unique
  // on a page. Unfortunately what it doesn't realize is that the IDs
  // we are generating are going to replace IDs that already exist, so
  // this actually works against us.
  if (isset($_POST['ajax_html_ids'])) {
    unset($_POST['ajax_html_ids']);
  }

  list($form, $form_state) = ajax_get_form();
  drupal_process_form($form['#form_id'], $form, $form_state);

  // Get the information on what we're removing.
  $button = $form_state['triggering_element'];
  // Go two levels up in the form, to the whole widget.
  $element = drupal_array_get_nested_value($form, array_slice($button['#array_parents'], 0, -4));
  // Now send back the proper AJAX command to replace it.
  $return = array(
    '#type' => 'ajax',
    '#commands' => array(
      ajax_command_replace('#' . $element['#id'], drupal_render($element))
    ),
  );

  // Because we're doing this ourselves, messages aren't automatic. We have
  // to add them.
  $messages = theme('status_messages');
  if ($messages) {
    $return['#commands'][] = ajax_command_prepend('#' . $element['#id'], $messages);
  }

  return $return;
}


/**
 * Page callback to handle AJAX for removing a paragraphs item.
 *
 * This is a direct page callback. The actual job of deleting the item is
 * done in the submit handler for the button, so all we really need to
 * do is process the form and then generate output. We generate this
 * output by doing a replace command on the id of the entire form element.
 */
function paragraphs_deleteconfirm_js() {
  // drupal_html_id() very helpfully ensures that all html IDS are unique
  // on a page. Unfortunately what it doesn't realize is that the IDs
  // we are generating are going to replace IDs that already exist, so
  // this actually works against us.
  if (isset($_POST['ajax_html_ids'])) {
    unset($_POST['ajax_html_ids']);
  }

  list($form, $form_state) = ajax_get_form();
  drupal_process_form($form['#form_id'], $form, $form_state);

  // Get the information on what we're removing.
  $button = $form_state['triggering_element'];
  // Go two levels up in the form, to the whole widget.
  $element = drupal_array_get_nested_value($form, array_slice($button['#array_parents'], 0, -4));
  // Now send back the proper AJAX command to replace it.
  $return = array(
    '#type' => 'ajax',
    '#commands' => array(
      ajax_command_replace('#' . $element['#id'], drupal_render($element))
    ),
  );

  // Because we're doing this ourselves, messages aren't automatic. We have
  // to add them.
  $messages = theme('status_messages');
  if ($messages) {
    $return['#commands'][] = ajax_command_prepend('#' . $element['#id'], $messages);
  }

  return $return;
}

/**
 * Page callback to handle AJAX for restoring a paragraphs item.
 *
 * This is a direct page callback. The actual job of deleting the item is
 * done in the submit handler for the button, so all we really need to
 * do is process the form and then generate output. We generate this
 * output by doing a replace command on the id of the entire form element.
 */
function paragraphs_restore_js() {
  // drupal_html_id() very helpfully ensures that all html IDS are unique
  // on a page. Unfortunately what it doesn't realize is that the IDs
  // we are generating are going to replace IDs that already exist, so
  // this actually works against us.
  if (isset($_POST['ajax_html_ids'])) {
    unset($_POST['ajax_html_ids']);
  }

  list($form, $form_state) = ajax_get_form();
  drupal_process_form($form['#form_id'], $form, $form_state);

  // Get the information on what we're removing.
  $button = $form_state['triggering_element'];
  // Go two levels up in the form, to the whole widget.
  $element = drupal_array_get_nested_value($form, array_slice($button['#array_parents'], 0, -4));
  // Now send back the proper AJAX command to replace it.
  $return = array(
    '#type' => 'ajax',
    '#commands' => array(
      ajax_command_replace('#' . $element['#id'], drupal_render($element))
    ),
  );

  // Because we're doing this ourselves, messages aren't automatic. We have
  // to add them.
  $messages = theme('status_messages');
  if ($messages) {
    $return['#commands'][] = ajax_command_prepend('#' . $element['#id'], $messages);
  }

  return $return;
}

/**
 * Gets a paragraphs item entity for a given field item.
 *
 * @param $field_name
 *   (optional) If given and there is no entity yet, a new entity object is
 *   created for the given item.
 *
 * @return
 *   The entity object or FALSE.
 */
function paragraphs_field_get_entity(&$item, $bundle = NULL, $field_name = NULL) {
  if (isset($item['entity'])) {
    return $item['entity'];
  }
  elseif (isset($item['value'])) {
    // By default always load the default revision, so caches get used.
    $entity = paragraphs_item_load($item['value']);
    if ($entity && $entity->revision_id != $item['revision_id']) {
      // A non-default revision is a referenced, so load this one.
      $entity = paragraphs_item_revision_load($item['revision_id']);
    }
    return $entity;
  }
  elseif (!isset($item['entity']) && isset($bundle) && isset($field_name)) {
    $item['entity'] = entity_create('paragraphs_item', array('bundle' => $bundle, 'field_name' => $field_name));
    return $item['entity'];
  }
  return FALSE;
}



/**
 * Implements hook_features_api().
 */
function paragraphs_features_api() {
  return array(
    'paragraphs' => array(
      'name' => t('Paragraphs Bundles'),
      'feature_source' => TRUE,
      'default_hook' => 'paragraphs_info',
    ),
  );
}

/**
 * Implements hook_features_export_options().
 */
function paragraphs_features_export_options() {
  $bundles = paragraphs_bundle_load();
  $names = array();
  foreach($bundles as $key => $value) {
    $names[$key] = $value->name;
  }
  return $names;
}

/**
 * Implements hook_features_export.
 */
function paragraphs_features_export($data, &$export, $module_name = '') {
  $pipe = array();
  $map = features_get_default_map('paragraphs');

  foreach ($data as $type) {
    if ($info = paragraphs_bundle_load($type)) {
      $export['features']['paragraphs'][$type] = $type;
      $export['dependencies']['paragraphs'] = 'paragraphs';
      $export['dependencies']['features'] = 'features';

      $fields = field_info_instances('paragraphs_item', $type);
      foreach ($fields as $name => $field) {
        $pipe['field_instance'][] = "paragraphs_item-{$field['bundle']}-{$field['field_name']}";
      }
    }
  }

  return $pipe;

}

/**
 * Implements hook_features_export_render().
 */
function paragraphs_features_export_render($module, $data, $export = NULL) {
  $elements = array(
    'name' => FALSE,
    'bundle' => FALSE,
    'locked' => FALSE,
  );
  $output = array();
  $output[] = '  $items = array(';
  foreach ($data as $type) {
    if ($info = paragraphs_bundle_load($type)) {
      $output[] = "    '{$type}' => array(";
      foreach ($elements as $key => $t) {
        if ($t) {
          $text = str_replace("'", "\'", $info->$key);
          $text = !empty($text) ? "t('{$text}')" : "''";
          $output[] = "      '{$key}' => {$text},";
        }
        else {
          $output[] = "      '{$key}' => '{$info->$key}',";
        }
      }
      $output[] = "    ),";
    }
  }
  $output[] = '  );';
  $output[] = '  return $items;';
  $output = implode("\n", $output);
  return array('paragraphs_info' => $output);
}

/**
 * Implements hook_features_revert().
 *
 * @param $module
 * name of module to revert content for
 */
function paragraphs_features_revert($module = NULL) {
  if ($default_types = features_get_default('paragraphs', $module)) {
    foreach ($default_types as $type_name => $type_info) {
      db_delete('paragraphs_bundle')
        ->condition('bundle', $type_name)
        ->execute();
      $bundle = new stdClass();
      $bundle->bundle = $type_info['bundle'];
      $bundle->locked = $type_info['locked'];
      $bundle->name = $type_info['name'];
      paragraphs_bundle_save($bundle);
    }
    paragraphs_bundle_load(NULL, TRUE);
    menu_rebuild();
  }
}




/**
 * Special handling to create form elements for multiple values.
 *
 * Handles generic features for multiple fields:
 * - number of widgets
 * - AHAH-'add more' button
 * - drag-n-drop value reordering
 */
function paragraphs_field_multiple_value_form($field, $instance, $langcode, $items, &$form, &$form_state) {
  $field_name = $field['field_name'];
  $parents = $form['#parents'];

  $field_state = field_form_get_state($parents, $field_name, $langcode, $form_state);
  $max = $field_state['items_count'] - 1;

  $title = check_plain($instance['label']);
  $description = field_filter_xss($instance['description']);

  $id_prefix = implode('-', array_merge($parents, array($field_name)));
  $wrapper_id = drupal_html_id($id_prefix . '-add-more-wrapper');

  $field_elements = array();

  $function = $instance['widget']['module'] . '_field_widget_form_build';
  if (function_exists($function)) {
    for ($delta = 0; $delta <= $max; $delta++) {
      $multiple = TRUE;
      $element = array(
        '#entity_type' => $instance['entity_type'],
        '#entity' => $form['#entity'],
        '#bundle' => $instance['bundle'],
        '#field_name' => $field_name,
        '#language' => $langcode,
        '#field_parents' => $parents,
        '#columns' => array_keys($field['columns']),
        // For multiple fields, title and description are handled by the wrapping table.
        '#title' => $multiple ? '' : $title,
        '#description' => $multiple ? '' : $description,
        // Only the first widget should be required.
        '#required' => $delta == 0 && $instance['required'],
        '#delta' => $delta,
        '#weight' => $delta,
      );
      if ($element = $function($form, $form_state, $field, $instance, $langcode, $items, $delta, $element)) {
        // Input field for the delta (drag-n-drop reordering).
        if ($multiple) {
          // We name the element '_weight' to avoid clashing with elements
          // defined by widget.
          $element['_weight'] = array(
            '#type' => 'weight',
            '#title' => t('Weight for row @number', array('@number' => $delta + 1)),
            '#title_display' => 'invisible',
            // Note: this 'delta' is the FAPI 'weight' element's property.
            '#delta' => $max,
            '#default_value' => isset($items[$delta]['_weight']) ? $items[$delta]['_weight'] : $delta,
            '#weight' => 100,
          );
        }

        // Allow modules to alter the field widget form element.
        $context = array(
          'form' => $form,
          'field' => $field,
          'instance' => $instance,
          'langcode' => $langcode,
          'items' => $items,
          'delta' => $delta,
        );
        drupal_alter(array('paragraphs_field_widget_form', 'paragraphs_field_widget_' . $instance['widget']['type'] . '_form'), $element, $form_state, $context);

        $field_elements[$delta] = $element;
      }
    }

    $field_elements += array(
      '#theme' => 'paragraphs_field_multiple_value_form',
      '#field_name' => $field['field_name'],
      '#cardinality' => $field['cardinality'],
      '#title' => $title,
      '#required' => $instance['required'],
      '#description' => $description,
      '#prefix' => '<div id="' . $wrapper_id . '">',
      '#suffix' => '</div>',
      '#max_delta' => $max,
      '#instance' => $instance,
    );

    if (module_exists('file')) {
      // file.js triggers uploads when the main Submit button is clicked.
      $field_elements['#attached']['js'] = array(
        drupal_get_path('module', 'file') . '/file.js',
        drupal_get_path('module', 'paragraphs') . '/paragraphs.js',
      );
    }

    // Add 'add more' button, if not working with a programmed form.
    if (empty($form_state['programmed'])) {
      $available_bundles = paragraphs_bundle_load();
      $select_bundles = array();

      foreach($instance['settings']['allowed_bundles'] as $allowed_bundle_key => $allowed_bundle_value) {
        if($allowed_bundle_key === $allowed_bundle_value && isset($available_bundles[$allowed_bundle_key])) {
          $select_bundles[$available_bundles[$allowed_bundle_key]->bundle] = $available_bundles[$allowed_bundle_key]->name;
        }
      }
      if(count($select_bundles)) {

        $field = $field_state['field'];

        if($field['cardinality'] == FIELD_CARDINALITY_UNLIMITED || $field_state['items_count'] < $field['cardinality']) {
          if(!isset($instance['settings']['title'])) {
            $instance['settings']['title'] = PARAGRAPHS_DEFAULT_TITLE;
          }

          $field_elements['add_more'] = array(
            '#type' => 'container',
            '#tree' => TRUE,
          );
          $field_elements['add_more']['type'] = array(
            '#type' => 'select',
            '#name' => strtr($id_prefix, '-', '_') . '_add_more_type',
            '#title' => t('!title type', array('!title' => t($instance['settings']['title']))),
            '#options' => $select_bundles,
            '#attributes' => array('class' => array('field-add-more-type')),
            '#limit_validation_errors' => array(array_merge($parents, array($field_name, $langcode))),
          );

          if(isset($form_state['input'][strtr($id_prefix, '-', '_') . '_add_more_type'])) {
            $field_elements['add_more']['type']['#default_value'] = $form_state['input'][strtr($id_prefix, '-', '_') . '_add_more_type'];
          }

          $text = 'Add a !title';
          if($max >= 0) {
            $text = 'Add another !title';
          }

          $field_elements['add_more']['add_more'] = array(
            '#type' => 'submit',
            '#name' => strtr($id_prefix, '-', '_') . '_add_more_add_more',
            '#value' => t($text, array('!title' => t($instance['settings']['title']))),
            '#attributes' => array('class' => array('field-add-more-submit', 'paragraphs-add-more-submit')),
            '#limit_validation_errors' => array(),
            '#submit' => array('paragraphs_add_more_submit'),
            '#ajax' => array(
              'callback' => 'paragraphs_add_more_js',
              'wrapper' => $wrapper_id,
              'effect' => 'fade',
            ),
          );
        }
      } else {
        $field_elements['add_more']['add_more'] = array(
          '#type' => 'markup',
          '#markup' => '<em>' . t('No bundles available, edit field settings') . '</em>',
        );
      }
    }
  }

  return $field_elements;
}

function paragraphs_add_more_submit($form, &$form_state) {
  $button = $form_state['triggering_element'];

  // Go one level up in the form, to the widgets container.
  $element = drupal_array_get_nested_value($form, array_slice($button['#array_parents'], 0, -2));
  $field_name = $element['#field_name'];
  $langcode = $element['#language'];
  $parents = $element['#field_parents'];

  // Increment the items count.
  $field_state = field_form_get_state($parents, $field_name, $langcode, $form_state);

  $field = $field_state['field'];

  if($field['cardinality'] == FIELD_CARDINALITY_UNLIMITED || $field_state['items_count'] < $field['cardinality']) {
    $field_state['items_count']++;
  }

  field_form_set_state($parents, $field_name, $langcode, $form_state, $field_state);

  $form_state['rebuild'] = TRUE;
}

/**
 * Ajax callback in response to a new empty widget being added to the form.
 *
 * This returns the new page content to replace the page content made obsolete
 * by the form submission.
 *
 * @see field_add_more_submit()
 */
function paragraphs_add_more_js($form, $form_state) {
  $button = $form_state['triggering_element'];

  // Go one level up in the form, to the widgets container.
  $element = drupal_array_get_nested_value($form, array_slice($button['#array_parents'], 0, -2));
  $field_name = $element['#field_name'];
  $langcode = $element['#language'];
  $parents = $element['#field_parents'];

  $field_state = field_form_get_state($parents, $field_name, $langcode, $form_state);

  $field = $field_state['field'];

  // Add a DIV around the delta receiving the Ajax effect.
  $delta = $element['#max_delta'];
  $element[$delta]['#prefix'] = '<div class="ajax-new-content">' . (isset($element[$delta]['#prefix']) ? $element[$delta]['#prefix'] : '');
  $element[$delta]['#suffix'] = (isset($element[$delta]['#suffix']) ? $element[$delta]['#suffix'] : '') . '</div>';

  return $element;
}

/**
 * Returns HTML for an individual form element.
 *
 * Combine multiple values into a table with drag-n-drop reordering.
 * TODO : convert to a template.
 *
 * @param $variables
 *   An associative array containing:
 *   - element: A render element representing the form element.
 *
 * @ingroup themeable
 */
function theme_paragraphs_field_multiple_value_form($variables) {
  $element = $variables['element'];
  $output = '';
  $instance = $element['#instance'];

  if(!isset($instance['settings']['title'])) {
    $instance['settings']['title'] = PARAGRAPHS_DEFAULT_TITLE;
  }
  if(!isset($instance['settings']['title_multiple'])) {
    $instance['settings']['title_multiple'] = PARAGRAPHS_DEFAULT_TITLE_MULTIPLE;
  }

  $table_id = drupal_html_id($element['#field_name'] . '_values');
  $order_class = $element['#field_name'] . '-delta-order';
  $required = !empty($element['#required']) ? theme('form_required_marker', $variables) : '';

  $header = array(
    array(
      'data' => '<label>' . t('!title !required', array('!title' => $element['#title'], '!required' => $required)) . "</label>",
      'colspan' => 2,
      'class' => array('field-label'),
    ),
    t('Order'),
  );
  $rows = array();

  // Sort items according to '_weight' (needed when the form comes back after
  // preview or failed validation)
  $items = array();
  foreach (element_children($element) as $key) {
    if ($key === 'add_more') {
      $add_more_button = &$element[$key];
    }
    else if ($key === 'add_more_type') {
      $add_more_button_type = &$element[$key];
    }
    else {
      $items[] = &$element[$key];
    }
  }
  usort($items, '_field_sort_items_value_helper');

  // Add the items as table rows.
  foreach ($items as $key => $item) {
    $item['_weight']['#attributes']['class'] = array($order_class);
    $delta_element = drupal_render($item['_weight']);
    $cells = array(
      array('data' => '', 'class' => array('field-multiple-drag')),
      drupal_render($item),
      array('data' => $delta_element, 'class' => array('delta-order')),
    );
    $rows[] = array(
      'data' => $cells,
      'class' => array('draggable'),
    );
  }

  $output = '<div class="form-item">';
  if(count($items)) {
    $output .= theme('table', array('header' => $header, 'rows' => $rows, 'attributes' => array('id' => $table_id, 'class' => array('field-multiple-table'))));
  } else {
    $output .= '<label>' . t('!title !required', array('!title' => $element['#title'], '!required' => $required)) . "</label>";
    $output .= '<p><em>' . t('No !title_multiple added yet. Select a !title type and press the button below to add one.', array('!title_multiple' => t($instance['settings']['title_multiple']), '!title' => t($instance['settings']['title']))) . '</em></p>';
  }
  $output .= $element['#description'] ? '<div class="description">' . $element['#description'] . '</div>' : '';
  $output .= '<div class="clearfix">' . drupal_render($add_more_button_type) . drupal_render($add_more_button) . '</div>';
  $output .= '</div>';

  drupal_add_tabledrag($table_id, 'order', 'sibling', $order_class);

  return $output;
}

/**
 * Themes paragraphs items printed using the paragraphs_view formatter.
 */
function theme_paragraphs_view($variables) {
  $element = $variables['element'];
  return '<div' . drupal_attributes($element['#attributes']) . '>' . $element['#children'] . '</div>';
}


/**
 * Implements hook_theme().
 */
function paragraphs_theme() {
  return array(
    'paragraphs_field_multiple_value_form' => array(
      'render element' => 'element',
    ),
    'paragraphs_view' => array(
      'render element' => 'element',
    ),
    'paragraphs_item' => array(
      'render element' => 'elements',
      'template' => 'paragraphs-item',
    ),
  );
}

/**
 * Implements hook_field_create_field().
 */
function paragraphs_field_create_field($field) {
  if ($field['type'] == 'paragraphs') {

    // Clear caches.
    entity_info_cache_clear();
    // Do not directly issue menu rebuilds here to avoid potentially multiple
    // rebuilds. Instead, let menu_get_item() issue the rebuild on the next
    // request.
    variable_set('menu_rebuild_needed', TRUE);
  }
}

/**
 * Implements hook_field_delete_field().
 */
function paragraphs_field_delete_field($field) {
  if ($field['type'] == 'paragraphs') {

    // Clear caches.
    entity_info_cache_clear();
    // Do not directly issue menu rebuilds here to avoid potentially multiple
    // rebuilds. Instead, let menu_get_item() issue the rebuild on the next
    // request.
    variable_set('menu_rebuild_needed', TRUE);
  }
}

/**
 * Implements hook_views_api().
 */
function paragraphs_views_api() {
  return array(
    'api' => '3.0-alpha1',
    'path' => drupal_get_path('module', 'paragraphs') . '/views',
  );
}

/**
 * Implements hook_module_implements_alter().
 */
function paragraphs_module_implements_alter(&$implementations, $hook) {
  switch ($hook) {
    case 'field_attach_form':
      // We put the implementation of field_attach_form implementation of
      // paragraphs at the end, so it has a chance to disable the implementation
      // of entity_translation that provides the form changes that will break
      // paragraphs.
      $group = $implementations['paragraphs'];
      unset($implementations['paragraphs']);
      $implementations['paragraphs'] = $group;
      break;
  }
}

/**
 * Implements hook_field_attach_form().
 */
function paragraphs_field_attach_form($entity_type, $entity, &$form, &$form_state, $langcode) {

  // We make sure paragraphs don't use the entity translation defaults, as those
  // are not implemented properly yet in paragraphs. So we better show an empty
  // initial field for a translation of an existing entity, than making
  // paragraphs break completely.
  // A proper implementation of entity_translation has still to be discussed.
  // @see https://drupal.org/node/2152931
  list( , , $bundle) = entity_extract_ids($entity_type, $entity);

  foreach (field_info_instances($entity_type, $bundle) as $instance) {

    $field_name = $instance['field_name'];
    $field_info = field_info_field($field_name);

    if ($field_info['type'] == 'paragraphs') {
      if (isset($form[$field_name])) {
        $element = &$form[$field_name];

        // Remove the entity_translation preparion for the element. This way we
        // avoid that there will be form elements that do not have a
        // corresponding form state for the field.
        if (!empty($element['#process'])) {
          $key = array_search('entity_translation_prepare_element', $element['#process']);

          if ($key !== FALSE)  {
            unset($element['#process'][$key]);
          }
        }
      }
    }
  }
}

/**
 * Implements hook_field_prepare_translation().
 *
 * @see field_attach_prepare_translation()
 */
function paragraphs_field_prepare_translation($entity_type, $entity, $field, $instance, $langcode, &$items, $source_entity, $source_langcode) {
  list($id, , ) = entity_extract_ids($entity_type, $entity);

  // field_attach_prepare_translation() copied the entity ids from the source,
  // as we need a new entity for a new translation, we cannot reuse that.
  // @todo clone existing paragraphs to new translation
  if (empty($id)) {
    $items = array();
  }
}
